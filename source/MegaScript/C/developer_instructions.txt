Hello!

Welcome to the developer instruction manual for MegaScript! This file contains all the info that developers may need when changing or adding new
features to the MegaScript language. I hope you find it helpful, and have a good time coding!

Operation Formatting:
    MegaScript operations can be very confusing if you don't know how they work, so this will explain in detail how they function!

    Operation Saves:
        Operation saves are a concept that I came up with specifically for the MegaScript language. Before I had added user-created functions, operations were
        done simply by running ExecuteMegaScriptOperation from inside that same function whenever an operator with higher precedence was reached, or a bracket was
        entered. I found that this would not be compatible with user created functions since a user function would require its own amount of statement cycles in order
        to be called. So I came up with a solution: Operation saves.
        
        When an operation is interrupted to enter a bracket, call a function, or simply postpone for a higher precedence, it will push an operation save onto the
        script's stack so that once that interrupt is returned back to, it can restore the operation to its former state. Operation saves are 32 bit unsigned integers.
        If you're curious about how an operation save is formatted, here's a table of what each bit of the save means:

        ╔════════════════════════════╦════════════════════════╦══════════════╦════════╦════════════════════╦══════════════╦═════════════════╦═════════════╦════════════════╦═══════════╗
        ║ Operators to restore count ║ Standard call bytecode ║ StopAtCommas ║ IsLoop ║ IsFunctionArgument ║ IsCallReturn ║ HasFunctionCall ║ HasBytecode ║ ResumePrevious ║ HasReturn ║
        ╠════════════════════════════╬════════════════════════╬══════════════╬════════╬════════════════════╬══════════════╬═════════════════╬═════════════╬════════════════╬═══════════╣
        ║ 0000000000000000           ║ 00000000               ║ 0            ║ 0      ║ 0                  ║ 0            ║ 0               ║ 0           ║ 0              ║ 0         ║
        ╚════════════════════════════╩════════════════════════╩══════════════╩════════╩════════════════════╩══════════════╩═════════════════╩═════════════╩════════════════╩═══════════╝

        All together, they form the 32 bit operation save, which can then be pushed onto the stack for later use.

        Alongside the regular script stack, there is also an operator storage stack which is stored in the script system. It behaves almost identically to the regular
        script stack, except it does not need data types to be pushed on since every element will always just be 1 byte. When an operation is restored, the operator
        count is analyzed, which then lets the program know how far into the operation the script was.

    Precedence:
        As of Update 1.4.0 Indev, operator precedence is now formatted similar to the way that c operator precedence is defined. Each precedence level has
        a group of operators that share that precedence level. These are called precedence groups. Each precedence group has an associativity value which can
        represent left-to-right, or right-to-left. All that this associativity value does is change which direction the operators of that group are executed.

        When you create a new script environment, it automatically creates a list called "operator_info." This list is an array of 256 OperatorInformation structs
        that are 4 bytes large. (The array is 1024 bytes large in total.) The reason it creates a member for every single possible byte is so that the members can
        be indexed by the byte number rather than having to search for which array member represents that byte, which makes the program run much faster.